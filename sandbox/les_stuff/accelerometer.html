<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mobile 3D Fall Detection Simulator</title>
<style>
  body { margin:0; font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background:#e0f7ff; overflow-x:hidden; }
  header { background:#4A90E2; color:white; padding:15px; font-size:1.6em; font-weight:bold; text-align:center; box-shadow:0 2px 10px rgba(0,0,0,0.2); }
  #dashboard { display:flex; flex-direction:column; align-items:center; padding:10px; max-width:100vw; }
  #status { font-size:22px; margin:8px; transition: all 0.5s ease; text-align:center; font-weight:bold; padding:10px; border-radius:8px; }
  #status.normal { background:#d4edda; color:#155724; }
  #status.fall { background:#f8d7da; color:#721c24; animation: pulse 0.5s ease-in-out infinite; }
  @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
  #acceleration { font-size:18px; margin:5px; transition: color 0.3s ease; text-align:center; font-weight:600; }
  #log { max-width:95vw; margin:10px auto; background:#fff; border-radius:10px; padding:10px; height:120px; overflow-y:auto; font-family:monospace; box-shadow:0 2px 8px rgba(0,0,0,0.1); font-size:12px; }
  #log p { margin:2px 0; padding:2px; }
  .log-fall { color:#d32f2f; font-weight:bold; }
  canvas { margin:5px; width:95vw !important; height:120px !important; border-radius:8px; background:#fff; box-shadow:0 1px 4px rgba(0,0,0,0.1); }
  button { padding:12px 25px; font-size:16px; margin:8px; border:none; border-radius:8px; cursor:pointer; font-weight:bold; min-width:120px; transition:all 0.3s ease; }
  button:disabled { opacity:0.5; cursor:not-allowed; }
  #startBtn { background-color:#4CAF50; color:white; }
  #startBtn:hover:not(:disabled) { background-color:#45a049; transform:translateY(-2px); box-shadow:0 4px 8px rgba(0,0,0,0.2); }
  #stopBtn { background-color:#f44336; color:white; }
  #stopBtn:hover:not(:disabled) { background-color:#e53935; transform:translateY(-2px); box-shadow:0 4px 8px rgba(0,0,0,0.2); }
  #graphs { display:flex; flex-direction:column; align-items:center; width:100%; }
  #3d-container { width:95vw; height:300px; margin:10px; border-radius:10px; overflow:hidden; box-shadow:0 4px 12px rgba(0,0,0,0.15); }
  .graph-label { font-size:14px; font-weight:600; margin:5px 0; color:#333; }
  #info { background:#fff3cd; color:#856404; padding:10px; margin:10px; border-radius:8px; max-width:90vw; font-size:14px; text-align:center; }
</style>
</head>
<body>

<header>Mobile 3D Fall Detection Simulator</header>
<div id="dashboard">
  <div id="info">üì± Enable device motion on your mobile device to start detection</div>
  <div id="status" class="normal">Ready to Start</div>
  <div id="acceleration">Acceleration: 0.00 m/s¬≤</div>

  <div id="3d-container"></div>

  <div id="graphs">
    <div class="graph-label">X-Axis Acceleration</div>
    <canvas id="xGraph" width="700" height="120"></canvas>
    <div class="graph-label">Y-Axis Acceleration</div>
    <canvas id="yGraph" width="700" height="120"></canvas>
    <div class="graph-label">Z-Axis Acceleration</div>
    <canvas id="zGraph" width="700" height="120"></canvas>
  </div>

  <div id="log"></div>
  <div>
    <button id="startBtn">Start Detection</button>
    <button id="stopBtn" disabled>Stop Detection</button>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
  // Constants
  const FALL_THRESHOLD = 3;
  const IMPACT_THRESHOLD = 25;
  const MIN_FALL_TIME = 200;
  const MAX_DATA_POINTS = 140;
  const MAX_TRAIL_POINTS = 50;
  const CUBE_SIZE = 6;

  // State
  let falling = false;
  let startTime = null;
  let isDetectionActive = false;
  const accelData = { x: [], y: [], z: [] };
  let trailPoints = [];

  // DOM Elements
  const statusEl = document.getElementById('status');
  const accelEl = document.getElementById('acceleration');
  const logEl = document.getElementById('log');
  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  const canvasX = document.getElementById('xGraph');
  const canvasY = document.getElementById('yGraph');
  const canvasZ = document.getElementById('zGraph');
  const ctxX = canvasX.getContext('2d');
  const ctxY = canvasY.getContext('2d');
  const ctxZ = canvasZ.getContext('2d');

  // Audio
  const audio = new Audio('https://actions.google.com/sounds/v1/alarms/alarm_clock.ogg');

  // 3D Setup
  const container = document.getElementById('3d-container');
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xe0f7ff);
  
  const camera = new THREE.PerspectiveCamera(
    75,
    container.clientWidth / container.clientHeight,
    0.1,
    1000
  );
  camera.position.set(8, 8, 8);
  camera.lookAt(0, 0, 0);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
  container.appendChild(renderer.domElement);

  // Simple orbit controls implementation
  let isDragging = false;
  let previousMousePosition = { x: 0, y: 0 };
  let cameraRotation = { x: 0, y: 0 };
  let cameraDistance = 12;

  renderer.domElement.addEventListener('mousedown', (e) => {
    isDragging = true;
    previousMousePosition = { x: e.clientX, y: e.clientY };
  });

  renderer.domElement.addEventListener('mousemove', (e) => {
    if (isDragging) {
      const deltaX = e.clientX - previousMousePosition.x;
      const deltaY = e.clientY - previousMousePosition.y;
      cameraRotation.y += deltaX * 0.01;
      cameraRotation.x += deltaY * 0.01;
      cameraRotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraRotation.x));
      previousMousePosition = { x: e.clientX, y: e.clientY };
    }
  });

  renderer.domElement.addEventListener('mouseup', () => {
    isDragging = false;
  });

  renderer.domElement.addEventListener('wheel', (e) => {
    e.preventDefault();
    cameraDistance += e.deltaY * 0.01;
    cameraDistance = Math.max(5, Math.min(20, cameraDistance));
  });

  // Touch controls
  let touchStart = null;
  renderer.domElement.addEventListener('touchstart', (e) => {
    if (e.touches.length === 1) {
      touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
    }
  });

  renderer.domElement.addEventListener('touchmove', (e) => {
    if (e.touches.length === 1 && touchStart) {
      const deltaX = e.touches[0].clientX - touchStart.x;
      const deltaY = e.touches[0].clientY - touchStart.y;
      cameraRotation.y += deltaX * 0.01;
      cameraRotation.x += deltaY * 0.01;
      cameraRotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraRotation.x));
      touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
    }
  });

  renderer.domElement.addEventListener('touchend', () => {
    touchStart = null;
  });

  // Create cube wireframe
  const geometry = new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE);
  const edges = new THREE.EdgesGeometry(geometry);
  const lineMaterial = new THREE.LineBasicMaterial({ color: 0x888888, linewidth: 2 });
  const cube = new THREE.LineSegments(edges, lineMaterial);
  scene.add(cube);

  // Create sphere
  const sphereGeom = new THREE.SphereGeometry(0.4, 32, 32);
  const sphereMat = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
  const sphere = new THREE.Mesh(sphereGeom, sphereMat);
  scene.add(sphere);

  // Create trail
  const trailGeom = new THREE.BufferGeometry();
  const trailPositions = new Float32Array(MAX_TRAIL_POINTS * 3);
  const trailColors = new Float32Array(MAX_TRAIL_POINTS * 3);
  trailGeom.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
  trailGeom.setAttribute('color', new THREE.BufferAttribute(trailColors, 3));
  const trailMat = new THREE.LineBasicMaterial({ vertexColors: true, transparent: true, opacity: 0.8 });
  const trailLine = new THREE.Line(trailGeom, trailMat);
  scene.add(trailLine);

  // Lighting
  scene.add(new THREE.AmbientLight(0xffffff, 0.6));
  const pointLight = new THREE.PointLight(0xffffff, 0.8);
  pointLight.position.set(10, 10, 10);
  scene.add(pointLight);

  // Pulse effect
  let pulseScale = 1;
  let pulseActive = false;

  function pulseSphere() {
    pulseActive = true;
    pulseScale = 1.8;
  }

  // Logging
  function logMessage(msg, isFall = false) {
    const p = document.createElement('p');
    p.textContent = `${new Date().toLocaleTimeString()}: ${msg}`;
    if (isFall) p.className = 'log-fall';
    logEl.appendChild(p);
    logEl.scrollTop = logEl.scrollHeight;
  }

  // Calculate total acceleration
  function calculateTotalAccel(x, y, z) {
    return Math.sqrt(x * x + y * y + z * z);
  }

  // Handle fall detection logic
  function handleFallLogic(totalAccel) {
    const currentTime = Date.now();
    accelEl.textContent = `Acceleration: ${totalAccel.toFixed(2)} m/s¬≤`;
    
    if (totalAccel > IMPACT_THRESHOLD) {
      accelEl.style.color = '#d32f2f';
    } else if (totalAccel > FALL_THRESHOLD) {
      accelEl.style.color = '#f57c00';
    } else {
      accelEl.style.color = '#388e3c';
    }

    if (totalAccel < FALL_THRESHOLD) {
      if (!falling) {
        falling = true;
        startTime = currentTime;
        statusEl.textContent = 'Falling Detected...';
        statusEl.className = 'fall';
        sphere.material.color.set(0xffff00);
        logMessage('Low acceleration detected - possible fall');
      }
    } else if (totalAccel > IMPACT_THRESHOLD && falling) {
      const duration = currentTime - startTime;
      if (duration >= MIN_FALL_TIME) {
        fallDetected(duration, totalAccel);
      }
      falling = false;
      startTime = null;
      statusEl.textContent = 'Monitoring...';
      statusEl.className = 'normal';
      sphere.material.color.set(0x00ff00);
    } else {
      if (falling && (currentTime - startTime) > 2000) {
        logMessage('Fall sequence ended without impact');
        falling = false;
        startTime = null;
        statusEl.textContent = 'Monitoring...';
        statusEl.className = 'normal';
        sphere.material.color.set(0x00ff00);
      }
    }
  }

  // Handle device motion event
  function handleMotionEvent(event) {
    if (!isDetectionActive) return;

    const acc = event.accelerationIncludingGravity;
    if (acc) {
      const x = acc.x || 0;
      const y = acc.y || 0;
      const z = acc.z || 0;

      // Store data
      accelData.x.push(x);
      accelData.y.push(y);
      accelData.z.push(z);

      if (accelData.x.length > MAX_DATA_POINTS) {
        accelData.x.shift();
        accelData.y.shift();
        accelData.z.shift();
      }

      const totalAccel = calculateTotalAccel(x, y, z);
      handleFallLogic(totalAccel);

      // Draw graphs
      drawGraph(ctxX, accelData.x, 'X-axis', '#2196F3');
      drawGraph(ctxY, accelData.y, 'Y-axis', '#4CAF50');
      drawGraph(ctxZ, accelData.z, 'Z-axis', '#FF9800');

      // Update 3D sphere position
      sphere.position.set(
        THREE.MathUtils.clamp(x * 0.3, -CUBE_SIZE / 2, CUBE_SIZE / 2),
        THREE.MathUtils.clamp(y * 0.3, -CUBE_SIZE / 2, CUBE_SIZE / 2),
        THREE.MathUtils.clamp(z * 0.3, -CUBE_SIZE / 2, CUBE_SIZE / 2)
      );

      // Update trail
      trailPoints.push({ pos: sphere.position.clone(), accel: totalAccel });
      if (trailPoints.length > MAX_TRAIL_POINTS) trailPoints.shift();

      const positions = trailGeom.attributes.position.array;
      const colors = trailGeom.attributes.color.array;
      
      for (let i = 0; i < trailPoints.length; i++) {
        const p = trailPoints[i];
        positions[i * 3] = p.pos.x;
        positions[i * 3 + 1] = p.pos.y;
        positions[i * 3 + 2] = p.pos.z;
        
        const t = Math.min(p.accel / IMPACT_THRESHOLD, 1);
        colors[i * 3] = t;
        colors[i * 3 + 1] = 1 - t;
        colors[i * 3 + 2] = 0;
      }
      
      trailGeom.setDrawRange(0, trailPoints.length);
      trailGeom.attributes.position.needsUpdate = true;
      trailGeom.attributes.color.needsUpdate = true;
    }
  }

  // Draw graph with auto-scaling
  function drawGraph(ctx, data, label, color) {
    const width = ctx.canvas.width;
    const height = ctx.canvas.height;
    const padding = 30;
    
    ctx.clearRect(0, 0, width, height);
    
    if (data.length === 0) return;

    // Find min/max for auto-scaling
    const minVal = Math.min(...data, -IMPACT_THRESHOLD);
    const maxVal = Math.max(...data, IMPACT_THRESHOLD);
    const range = maxVal - minVal || 1;

    const scaleY = (val) => {
      return height - padding - ((val - minVal) / range) * (height - 2 * padding);
    };

    // Draw grid
    ctx.strokeStyle = '#e0e0e0';
    ctx.lineWidth = 1;
    for (let i = 0; i <= 4; i++) {
      const y = padding + (i * (height - 2 * padding) / 4);
      ctx.beginPath();
      ctx.moveTo(padding, y);
      ctx.lineTo(width - padding, y);
      ctx.stroke();
    }

    // Draw threshold lines
    const fallY = scaleY(FALL_THRESHOLD);
    const impactY = scaleY(IMPACT_THRESHOLD);
    
    ctx.strokeStyle = '#f57c00';
    ctx.setLineDash([5, 5]);
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(padding, fallY);
    ctx.lineTo(width - padding, fallY);
    ctx.stroke();
    
    ctx.strokeStyle = '#d32f2f';
    ctx.beginPath();
    ctx.moveTo(padding, impactY);
    ctx.lineTo(width - padding, impactY);
    ctx.stroke();
    ctx.setLineDash([]);

    // Draw data line
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    
    const step = (width - 2 * padding) / (MAX_DATA_POINTS - 1);
    for (let i = 0; i < data.length; i++) {
      const x = padding + i * step;
      const y = scaleY(data[i]);
      if (i === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    }
    ctx.stroke();

    // Draw labels
    ctx.fillStyle = '#333';
    ctx.font = 'bold 12px Arial';
    ctx.fillText(`${maxVal.toFixed(1)}`, 5, padding);
    ctx.fillText(`${minVal.toFixed(1)}`, 5, height - padding);
  }

  // Fall detected
  function fallDetected(duration, impact) {
    logMessage(`‚ö†Ô∏è FALL DETECTED! Duration: ${duration.toFixed(0)}ms, Impact: ${impact.toFixed(2)} m/s¬≤`, true);
    statusEl.textContent = '‚ö†Ô∏è FALL DETECTED!';
    statusEl.className = 'fall';
    sphere.material.color.set(0xff0000);
    audio.play().catch(e => console.log('Audio blocked:', e));
    if (navigator.vibrate) {
      navigator.vibrate([500, 200, 500, 200, 500]);
    }
    pulseSphere();
  }

  // Start detection
  function startFallDetection() {
    if (!('DeviceMotionEvent' in window)) {
      logMessage('‚ùå DeviceMotion API not supported on this device');
      statusEl.textContent = 'Not Supported';
      statusEl.className = 'fall';
      return;
    }

    if (typeof DeviceMotionEvent.requestPermission === 'function') {
      DeviceMotionEvent.requestPermission()
        .then(permissionState => {
          if (permissionState === 'granted') {
            window.addEventListener('devicemotion', handleMotionEvent);
            isDetectionActive = true;
            logMessage('‚úÖ Fall detection started (iOS permission granted)');
            statusEl.textContent = 'Monitoring...';
            statusEl.className = 'normal';
            startBtn.disabled = true;
            stopBtn.disabled = false;
          } else {
            logMessage('‚ùå Permission denied');
            statusEl.textContent = 'Permission Denied';
            statusEl.className = 'fall';
          }
        })
        .catch(err => {
          console.error(err);
          logMessage('‚ùå Error requesting permission');
          statusEl.textContent = 'Error';
          statusEl.className = 'fall';
        });
    } else {
      window.addEventListener('devicemotion', handleMotionEvent);
      isDetectionActive = true;
      logMessage('‚úÖ Fall detection started');
      statusEl.textContent = 'Monitoring...';
      statusEl.className = 'normal';
      startBtn.disabled = true;
      stopBtn.disabled = false;
    }
  }

  // Stop detection
  function stopFallDetection() {
    window.removeEventListener('devicemotion', handleMotionEvent);
    isDetectionActive = false;
    falling = false;
    startTime = null;
    logMessage('‚èπÔ∏è Fall detection stopped');
    statusEl.textContent = 'Stopped';
    statusEl.className = 'normal';
    sphere.material.color.set(0x00ff00);
    trailPoints = [];
    startBtn.disabled = false;
    stopBtn.disabled = true;
  }

  // Event listeners
  startBtn.addEventListener('click', startFallDetection);
  stopBtn.addEventListener('click', stopFallDetection);

  // Animation loop
  function animate() {
    requestAnimationFrame(animate);
    
    // Update camera position based on rotation
    camera.position.x = Math.sin(cameraRotation.y) * Math.cos(cameraRotation.x) * cameraDistance;
    camera.position.y = Math.sin(cameraRotation.x) * cameraDistance;
    camera.position.z = Math.cos(cameraRotation.y) * Math.cos(cameraRotation.x) * cameraDistance;
    camera.lookAt(0, 0, 0);
    
    // Rotate cube slowly
    cube.rotation.x += 0.002;
    cube.rotation.y += 0.003;
    
    // Pulse effect
    if (pulseActive) {
      sphere.scale.set(pulseScale, pulseScale, pulseScale);
      pulseScale -= 0.05;
      if (pulseScale <= 1) {
        pulseScale = 1;
        pulseActive = false;
      }
    }
    
    renderer.render(scene, camera);
  }
  animate();

  // Handle window resize
  window.addEventListener('resize', () => {
    camera.aspect = container.clientWidth / container.clientHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(container.clientWidth, container.clientHeight);
  });

  // Initial log
  logMessage('üì± Application loaded. Press "Start Detection" to begin.');
</script>

</body>
</html>